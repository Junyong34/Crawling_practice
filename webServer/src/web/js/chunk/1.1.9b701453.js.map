{"version":3,"file":"js\\chunk\\1.1.9b701453.js","sources":["webpack:///./src/components/common/chart/chartUtil.js"],"sourcesContent":["// const defaultColor = [\"#00c5cd\", \"#009bc7\", \"#cacaff\", \"#ffc125\", \"#df6264\", \"#2b99f0\", \"#8ac449\", \"#009697\", \"#959c2c\", \"#004ae7\", \"#01cc00\", \"#15679a\", \"#43bcd7\", \"#e76627\", \"#5C8558\", \"#A8A5A3\", \"#498700\", \"#832C2D\", \"#C98C5A\", \"#3478BE\", \"#BCF061\", \"#B26600\", \"#27358F\", \"#A4534D\", \"#B89630\", \"#A865B4\", \"#254763\", \"#536859\", \"#3ca0ff\", \"#90db3b\", \"#00c4c5\", \"#ffde00\", \"#ff7781\", \"#8470ff\", \"#75cd8e\", \"#48d1cc\", \"#fec64f\", \"#fe984f\", \"#0052ff\", \"#00a48c\", \"#83cfde\", \"#dfe32d\", \"#ff7d40\", \"#99c7ff\", \"#a5fee3\", \"#0379c9\", \"#eef093\", \"#ffa891\", \"#E9F378\", \"#888A79\", \"#D67D4B\", \"#2BEC69\", \"#4A2BEC\", \"#2BBEEC\", \"#DDACDF\"];\r\nconst defaultColor = [\r\n\t'#198fff',\r\n\t'#15efb4',\r\n\t'#e97fd7',\r\n\t'#ffb960',\r\n\t'#8c4ee6',\r\n\t'#e2e2e2',\r\n\t'#fbff60',\r\n\t'#ef4a79',\r\n\t'#58b632',\r\n\t'#5f52dc',\r\n\t'#105393',\r\n\t'#0f6b52',\r\n\t'#842073',\r\n\t'#845212',\r\n\t'#541f9f',\r\n\t'#7d7d7d',\r\n\t'#aeb143',\r\n\t'#642033',\r\n\t'#5d844e',\r\n\t'#637cb2',\r\n];\r\n\r\nconst stackChartColor = [\r\n\t'#cdcdcd',\r\n\t'#28ad90',\r\n\t'#d32f76',\r\n\t'#446b0d',\r\n\t'#ffac4f',\r\n\t'#97d5e2',\r\n\t'#ec542e',\r\n\t'#1d4c8b',\r\n\t'#f6d257',\r\n\t'#479de2',\r\n];\r\n\r\nconst barChartColor = ['#f70000', '#fbdd00', '#76ff9d', '#928aff', '#10d6d6'];\r\n\r\nconst extraColor = ['#4caf50', '#f44336', '#ff9800', '#2196f3'];\r\n\r\nconst markLineColor = ['#ff7a17', '#ff1357'];\r\n\r\nconst alarmColor = {\r\n\twarning: '#f8a30d',\r\n\tcritical: '#ff1f3f',\r\n};\r\n\r\nconst itemDataset = {\r\n\tnormal: {\r\n\t\t// color: function(params) {\r\n\t\t//     // build a color map as your need.\r\n\t\t//     var colorList = [\r\n\t\t//         \"#00c5cd\", \"#009bc7\", \"#cacaff\", \"#ffc125\", \"#df6264\",\r\n\t\t//         \"#2b99f0\", \"#8ac449\", \"#009697\", \"#959c2c\", \"#004ae7\", \"#01cc00\", \"#15679a\",\r\n\t\t//         \"#43bcd7\", \"#e76627\", \"#5C8558\", \"#A8A5A3\", \"#498700\", \"#832C2D\", \"#C98C5A\", \"#3478BE\",\r\n\t\t//         \"#BCF061\", \"#B26600\", \"#27358F\", \"#A4534D\", \"#B89630\", \"#A865B4\", \"#254763\", \"#536859\",\r\n\t\t//         \"#3ca0ff\", \"#90db3b\", \"#00c4c5\", \"#ffde00\", \"#ff7781\",\r\n\t\t//         \"#8470ff\", \"#75cd8e\", \"#48d1cc\", \"#fec64f\", \"#fe984f\",\r\n\t\t//         \"#0052ff\", \"#00a48c\", \"#83cfde\", \"#dfe32d\", \"#ff7d40\",\r\n\t\t//         \"#99c7ff\", \"#a5fee3\", \"#0379c9\", \"#eef093\", \"#ffa891\",\r\n\t\t//         \"#E9F378\", \"#888A79\", \"#D67D4B\", \"#2BEC69\", \"#4A2BEC\", \"#2BBEEC\", \"#DDACDF\"];\r\n\t\t//     return colorList[params.dataIndex]\r\n\t\t// },\r\n\t},\r\n\temphasis: {\r\n\t\tbarBorderWidth: 1,\r\n\t\tshadowBlur: 10,\r\n\t\tshadowOffsetX: 0,\r\n\t\tshadowOffsetY: 0,\r\n\t\tshadowColor: 'rgba(0,0,0,0.5)',\r\n\t},\r\n};\r\n\r\nconst quantity = input => {\r\n\tlet output;\r\n\r\n\tif (typeof input === 'string' || typeof input === 'number') {\r\n\t\tconst match = /^(normal|(\\d+(?:\\.\\d+)?)(px|%)?)$/.exec(input);\r\n\r\n\t\toutput = match\r\n\t\t\t? {\r\n\t\t\t\t\tvalue: +match[2],\r\n\t\t\t\t\tunit: match[3] || undefined,\r\n\t\t\t  }\r\n\t\t\t: undefined;\r\n\t} else {\r\n\t\toutput = undefined;\r\n\t}\r\n\treturn output;\r\n};\r\n\r\nconst hexToRgb = hex => {\r\n\tif (!hex) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tconst result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n\r\n\tconst r = parseInt(result[1], 16);\r\n\tconst g = parseInt(result[2], 16);\r\n\tconst b = parseInt(result[3], 16);\r\n\r\n\treturn `${r},${g},${b}`;\r\n};\r\n\r\nconst optionMixin = (opt1, opt2) => Object.assign(opt1, opt2);\r\n\r\nconst toDecimal = (n, d) => {\r\n\tif (typeof n === 'number') {\r\n\t\tconst pow = Math.pow(10, d);\r\n\r\n\t\t// console.log(Math.round(n * pow), pow, Math.round(n * pow) / pow);\r\n\t\treturn Math.round(n * pow) / pow;\r\n\t}\r\n\treturn n;\r\n};\r\n\r\nconst networkUnit = n => {\r\n\tconst cal = n / Math.pow(1024, 2);\r\n\r\n\treturn toDecimal(cal, 2);\r\n};\r\n\r\nconst memoryUnit = n => {\r\n\tconst cal = n / Math.pow(1024, 3);\r\n\r\n\treturn toDecimal(cal, 2);\r\n};\r\n\r\nconst fromBytes = (bytes, unit, decimals = 2) => {\r\n\tconst k = 1024;\r\n\tconst dm = decimals < 0 ? 0 : decimals;\r\n\tconst sizes = ['byte', 'Kib', 'Mib', 'Gib'];\r\n\tconst i = sizes.findIndex(v => v.toLowerCase() === unit.toLowerCase());\r\n\r\n\tif (i === -1) {\r\n\t\treturn bytes;\r\n\t}\r\n\treturn (parseFloat(bytes) / Math.pow(k, i)).toFixed(dm);\r\n};\r\n\r\nconst fromSec = sec => {\r\n\tconst k = 1000;\r\n\tlet _sec = sec;\r\n\tlet i = 0;\r\n\tconst sizes = ['sec', 'ms', 'μs', 'ns', 'ps'];\r\n\r\n\twhile (_sec < 0.1) {\r\n\t\t_sec *= k;\r\n\t\ti++;\r\n\t}\r\n\r\n\treturn { unit: sizes[i], mul: Math.pow(k, i) };\r\n};\r\n\r\nconst getChartMaxData = dataSet => {\r\n\t// 배열로 입력된 값 중 가장 큰 값의 단위를 찾는다.\r\n\tif (dataSet.length === 0) {\r\n\t\treturn 0;\r\n\t}\r\n\tconst numberSet = dataSet.map(v => v * 1);\r\n\tconst maxValue = numberSet.reduce((prev, curr) => (prev > curr ? prev : curr));\r\n\r\n\treturn maxValue;\r\n};\r\n\r\nconst autoBytesUnit = (arr, type = null) => {\r\n\t/**\r\n\t * 배열로 된 숫자 값이 오면 가장 큰 용량의 단위로 변환해서 표기해준다.\r\n\t * 변환하는 값은 0.1 보다 커야한다.\r\n\t */\r\n\tconst k = 1024;\r\n\tconst sizes = ['byte', 'KiB', 'MiB', 'GiB'];\r\n\tlet index = 0;\r\n\tlet maxResult;\r\n\r\n\tif (typeof arr === 'object') {\r\n\t\tmaxResult = getChartMaxData(arr);\r\n\t}\r\n\r\n\tfor (let jx = 0; jx < sizes.length; jx++) {\r\n\t\tif (maxResult / k > 0.2) {\r\n\t\t\tmaxResult /= k;\r\n\t\t\tindex++;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t// 소숫점인지 유무를 체크해서 소숫점은 2자리까지 표기해준다.\r\n\tconst result = arr.map(v => {\r\n\t\tconst value = v / Math.pow(k, index);\r\n\r\n\t\tif (value % 1 !== 0) {\r\n\t\t\treturn value.toFixed(2);\r\n\t\t}\r\n\t\treturn value;\r\n\t});\r\n\r\n\tconst bytes = {\r\n\t\tdata: result,\r\n\t\tunits: sizes[index],\r\n\t};\r\n\r\n\treturn !type ? bytes : bytes[type];\r\n};\r\n\r\nconst autoSecondsUnit = (arr, type = null) => {\r\n\t/**\r\n\t * 배열로 된 숫자 값이 오면 가장 작은 처리속도 단위로 변환해서 표기해준다.\r\n\t * 변환하는 값은 0.1 보다 작아야한다.\r\n\t */\r\n\tconst k = 1000;\r\n\tconst unit = ['sec', 'ms', 'µs', 'ns'];\r\n\tlet index = 0;\r\n\tlet maxResult;\r\n\r\n\tif (typeof arr === 'object') {\r\n\t\tmaxResult = getChartMaxData(arr);\r\n\t}\r\n\r\n\tfor (let jx = 0; jx < unit.length; jx++) {\r\n\t\tif (maxResult !== 0 && maxResult * k < 0.1) {\r\n\t\t\tmaxResult *= k;\r\n\t\t\tindex++;\r\n\t\t}\r\n\t}\r\n\r\n\tconst result = arr.map(v => (v * Math.pow(k, index)).toFixed(2));\r\n\r\n\tconst seconds = {\r\n\t\tdata: result,\r\n\t\tunits: unit[index],\r\n\t};\r\n\r\n\treturn !type ? seconds : seconds[type];\r\n};\r\n\r\nconst getData = (data, locations) => {\r\n\t// console.log(data, locations);\r\n\tlet returnData = [];\r\n\r\n\tif (Array.isArray(locations)) {\r\n\t\treturnData = data;\r\n\t\tlocations.forEach(location => {\r\n\t\t\tif (returnData) {\r\n\t\t\t\tif (Array.isArray(returnData)) {\r\n\t\t\t\t\treturnData = returnData.map(v => v[location]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturnData = returnData[location];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t} else {\r\n\t\treturnData = data[locations];\r\n\t}\r\n\r\n\t// console.log(returnData);\r\n\treturn returnData;\r\n};\r\n\r\nconst parsingChartData = (chartData, formatters) => {\r\n\tif (!chartData) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst parseData = [];\r\n\tconst arrFormatter = Object.entries(formatters);\r\n\tlet key = '';\r\n\tlet format = {};\r\n\tlet func = () => {};\r\n\tlet arg = [];\r\n\tlet ix = 0;\r\n\r\n\tchartData.forEach(d => {\r\n\t\tconst data = {};\r\n\r\n\t\tarrFormatter.forEach(formatter => {\r\n\t\t\t// formatter[0] - key, formatter[1] - value\r\n\t\t\t// [key, format] = formatter;\r\n\t\t\tkey = formatter[0];\r\n\t\t\tformat = formatter[1];\r\n\r\n\t\t\t// chartData 에서 원하는 property 값을 가져온다.\r\n\t\t\t// default값이 있다면 default값을 넣어준다.\r\n\t\t\tdata[key] = format.default ? format.default : getData(d, format.locations);\r\n\r\n\t\t\t// TODO: 불필요한 반복문 실행이 될수 있음..\r\n\t\t\t// 설정한 type이 있다면 type을 변화 시켜준다.\r\n\t\t\tif (format.type) {\r\n\t\t\t\tif (Array.isArray(data[key])) {\r\n\t\t\t\t\tdata[key] = data[key].map(v => format.type(v));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// data[key] = format.type(data[key]);\r\n\t\t\t\t\tdata[key] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 함수가 있을 경우 함수를 실행해 반환값을 받아온다.\r\n\t\t\tif (format.converter) {\r\n\t\t\t\t// value.converter - [function, arguments]\r\n\t\t\t\t// [func, arg] = format.converter;\r\n\t\t\t\tfunc = format.converter[0];\r\n\t\t\t\t// shallow copy..\r\n\t\t\t\targ = [...format.converter[1]];\r\n\t\t\t\t// 각각 개별로 처리할 경우 value, 전부를 처리할 경우 values\r\n\t\t\t\tif (arg.indexOf('value') !== -1) {\r\n\t\t\t\t\tix = arg.indexOf('value');\r\n\t\t\t\t\tif (Array.isArray(data[key])) {\r\n\t\t\t\t\t\tdata[key] = data[key].map(v => {\r\n\t\t\t\t\t\t\t// 배열 데이터(data, timestamp)는 숫자로 변경.\r\n\t\t\t\t\t\t\targ[ix] = v;\r\n\t\t\t\t\t\t\treturn func(...arg);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 하나일 경우는 id일 경우..\r\n\t\t\t\t\t\targ[ix] = data[key];\r\n\t\t\t\t\t\tdata[key] = func(...arg);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (arg.indexOf('values') !== -1) {\r\n\t\t\t\t\tix = arg.indexOf('values');\r\n\t\t\t\t\tif (Array.isArray(data[key])) {\r\n\t\t\t\t\t\targ[ix] = data[key];\r\n\t\t\t\t\t\tdata[key] = func(...arg);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO: 매개변수가 없을 경우 고려..\r\n\t\t\t\t\tconsole.error(\"don't exist value or values\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tparseData.push(data);\r\n\t});\r\n\r\n\t// TODO: 한개면 배열로 보내지 않는다...\r\n\t// return parseData.length === 1 ? parseData[0] : parseData;\r\n\treturn parseData;\r\n};\r\n\r\nconst timeConverter = [value => value * 1000, ['value']];\r\n\r\nexport default {\r\n\tdefaultColor,\r\n\tstackChartColor,\r\n\tbarChartColor,\r\n\textraColor,\r\n\tmarkLineColor,\r\n\talarmColor,\r\n\titemDataset,\r\n\tquantity,\r\n\thexToRgb,\r\n\toptionMixin,\r\n\ttoDecimal,\r\n\tnetworkUnit,\r\n\tmemoryUnit,\r\n\tfromBytes,\r\n\tfromSec,\r\n\tautoBytesUnit,\r\n\tautoSecondsUnit,\r\n\tparsingChartData,\r\n\ttimeConverter,\r\n};\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAuBA;AAaA;AAEA;AAEA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AALA;AAjBA;AACA;AAyBA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;;;;A","sourceRoot":""}